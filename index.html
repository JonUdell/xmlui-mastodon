<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://docs.xmlui.org/resources/files/for-download/xmlui/xmlui-standalone.umd.js"></script>
  <script src="config.js"></script>

  <style>
    /* Truncation rules moved into a class for toggling */
    .truncate-links a[href] {
      display: inline-block;
      max-width: 300px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: bottom;
    }

    .truncate-links a[href] span.ellipsis {
      display: inline;
    }

    .truncate-links a[href] span.invisible {
      display: none;
    }
  </style>

  <script>

    window.init = function () {
      sql = `select steampipe_configure_mastodon('access_token="${window.config.mastodonToken}"
    server="${window.config.server}"
    app="${window.config.app}"')`
      //console.log(sql)
      return { sql: sql }
    }

    window.ephemeralData = ''

    window.query = 'http://localhost:8080/query'

    // followers

    window.createFollower = function () {
      return {
        sql: `
          create table follower as select * from mastodon_my_follower
        `
      }
    }

    window.followers = function () {
      return {
        sql: `
          select
            f.account_id,
            f.id,
            f.acct,
            f.created_at,
            f.url,
            f.instance_qualified_account_url,
            f.username,
            f.server,
            f.display_name,
            f.followers_count,
            f.following_count,
            f.statuses_count,
            f.note,
            json_extract(f.account, '$.avatar') as avatar_url,
            case when fl.id is not null then 1 else 0 end as mutual
          from follower f
          left join following fl on fl.id = f.id
          order by f.created_at desc
        `
      }
    }

    window.updateFollower = `
      with limited_followers as (
        select *
        from mastodon_my_follower
        limit 20
      )
      insert into follower (
        _ctx,
        account,
        account_id,
        acct,
        created_at,
        display_name,
        followers_count,
        following_count,
        id,
        instance_qualified_account_url,
        note,
        server,
        sp_connection_name,
        sp_ctx,
        statuses_count,
        url,
        username
      )
      select
        _ctx,
        account,
        account_id,
        acct,
        created_at,
        display_name,
        followers_count,
        following_count,
        id,
        instance_qualified_account_url,
        note,
        server,
        sp_connection_name,
        sp_ctx,
        statuses_count,
        url,
        username
      from limited_followers src
      where not exists (
        select 1
        from follower
        where follower.id = src.id
      );
      `

    window.countFollower = `
      select count(*) from follower
    `


    // following

    window.createFollowing = function () {
      return {
        sql: `
          create table following as select * from mastodon_my_following
        `
      }
    }

    window.following = function () {
      return {
        sql: `
        select
          f.account_id,
          f.id,
          f.acct,
          f.created_at,
          f.url,
          f.instance_qualified_account_url,
          f.username,
          f.server,
          f.display_name,
          f.followers_count,
          f.following_count,
          f.statuses_count,
          f.note,
          json_extract(f.account, '$.avatar') as avatar_url,
          case when fl.id is not null then 1 else 0 end as mutual
        from following f
        left join follower fl on fl.id = f.id
        order by f.created_at desc
        `
      }
    }

    window.updateFollowing = `
      with limited_following as (
        select *
        from mastodon_my_following
        limit 20
      )
      insert into following (
        _ctx,
        account,
        account_id,
        acct,
        created_at,
        display_name,
        followers_count,
        following_count,
        id,
        instance_qualified_account_url,
        note,
        server,
        sp_connection_name,
        sp_ctx,
        statuses_count,
        url,
        username
      )
      select
        _ctx,
        account,
        account_id,
        acct,
        created_at,
        display_name,
        followers_count,
        following_count,
        id,
        instance_qualified_account_url,
        note,
        server,
        sp_connection_name,
        sp_ctx,
        statuses_count,
        url,
        username
      from limited_following src
      where not exists (
        select 1
        from following
        where following.id = src.id
      );
      `

    window.countFollowing = `
      select count(*) from following
    `

    // home

    window.tootsHome = function (count) {
      return {
        sql: `
            select
                case
                  when reblog is not null then json_extract(reblog, '$.id')
                  else id
                end as id,
                username,
                display_name,
                created_at,
                url,
                instance_qualified_url,
                instance_qualified_account_url,
                status,
                reblog,
                json_extract(status, '$.content') as content,
                case
                  when reblog is not null then cast(json_extract(reblog, '$.replies_count') as integer)
                  else cast(json_extract(status, '$.replies_count') as integer)
                end as replies_count,
                case
                  when reblog is not null then cast(json_extract(reblog, '$.reblogs_count') as integer)
                  else cast(json_extract(status, '$.reblogs_count') as integer)
                end as reblogs_count,
                case
                  when reblog is not null then cast(json_extract(reblog, '$.favourites_count') as integer)
                  else cast(json_extract(status, '$.favourites_count') as integer)
                end as favourites_count,
                case
                  when reblog is not null then json_extract(reblog, '$.favourited')
                  else json_extract(status, '$.favourited')
                end as favourited,
                case
                  when reblog is not null then json_extract(reblog, '$.reblogged')
                  else json_extract(status, '$.reblogged')
                end as reblogged,
                case
                  when reblog is not null then json_extract(reblog, '$.bookmarked')
                  else json_extract(status, '$.bookmarked')
                end as bookmarked,
                json_extract(account, '$.avatar') as avatar_url,
                json_extract(account, '$.header') as header_url,
                json_extract(account, '$.note') as note,
                json_extract(account, '$.followers_count') as followers_count,
                json_extract(account, '$.following_count') as following_count,
                json_extract(account, '$.statuses_count') as statuses_count,
                case
                  when reblog is not null then json_extract(reblog, '$.account.avatar')
                  else null
                end as reblog_avatar_url,
                case
                  when reblog is not null then json_extract(reblog, '$.account.header')
                  else null
                end as reblog_header_url,
                case
                  when reblog is not null then json_extract(reblog, '$.account.note')
                  else null
                end as reblog_note,
                case
                  when reblog is not null then json_extract(reblog, '$.account.followers_count')
                  else null
                end as reblog_followers_count,
                case
                  when reblog is not null then json_extract(reblog, '$.account.following_count')
                  else null
                end as reblog_following_count,
                case
                  when reblog is not null then json_extract(reblog, '$.account.statuses_count')
                  else null
                end as reblog_statuses_count,
                case
                  when reblog is not null then json_extract(reblog, '$.account.display_name')
                  else null
                end as reblog_display_name,
                case
                  when reblog is not null then json_extract(reblog, '$.account.username')
                  else null
                end as reblog_username,
                case
                  when reblog is not null then json_extract(reblog, '$.content')
                  else null
                end as reblog_content,
                case
                  when reblog is not null then json_extract(reblog, '$.created_at')
                  else null
                end as reblog_created_at,
                case
                  when reblog is not null then json_extract(reblog, '$.account.url')
                  else null
                end as reblog_account_url,
                case
                  when reblog is not null then json_extract(reblog, '$.in_reply_to_id')
                  else json_extract(status, '$.in_reply_to_id')
                end as in_reply_to_id,
                case
                  when reblog is not null then json_extract(reblog, '$.in_reply_to_account_id')
                  else json_extract(status, '$.in_reply_to_account_id')
                end as in_reply_to_account_id,
                json_extract(status, '$.media_attachments[0].preview_url') as preview_url,
                json_extract(status, '$.media_attachments[0].url') as media_url,
                json_extract(status, '$.media_attachments[0].type') as media_type,
                case
                  when reblog is not null then json_extract(reblog, '$.media_attachments[0].preview_url')
                  else null
                end as reblog_preview_url,
                case
                  when reblog is not null then json_extract(reblog, '$.media_attachments[0].url')
                  else null
                end as reblog_media_url,
                case
                  when reblog is not null then json_extract(reblog, '$.media_attachments[0].type')
                  else null
                end as reblog_media_type,
            instance_qualified_account_url
            from mastodon_toot_home
            order by created_at desc
            limit ${count}
            `
      }
    }

    // Fetch additional replies from toots_home persistence layer
    // that aren't in the current mastodon_toot_home API window
    window.getRepliesFromPersistence = function (parentIds) {
      const idList = parentIds.map(id => `'${id}'`).join(',');
      return {
        sql: `
          WITH RECURSIVE thread_replies AS (
            -- Direct replies to parents
            SELECT
              id, author_name, reblog_author_name, created_at, reblog_created_at,
              content, reblog_content, url, in_reply_to_id, in_reply_to_account_id,
              account_id, replies_count, preview_url, media_url, media_type,
              reblog_preview_url, reblog_media_url, reblog_media_type,
              1 as depth
            FROM toots_home
            WHERE in_reply_to_id IN (${idList})

            UNION ALL

            -- Recursive: replies to replies
            SELECT
              t.id, t.author_name, t.reblog_author_name, t.created_at, t.reblog_created_at,
              t.content, t.reblog_content, t.url, t.in_reply_to_id, t.in_reply_to_account_id,
              t.account_id, t.replies_count, t.preview_url, t.media_url, t.media_type,
              t.reblog_preview_url, t.reblog_media_url, t.reblog_media_type,
              thread_replies.depth + 1 as depth
            FROM toots_home t
            INNER JOIN thread_replies ON t.in_reply_to_id = thread_replies.id
            WHERE thread_replies.depth < 10
          )
          SELECT * FROM thread_replies
          ORDER BY created_at ASC
        `
      }
    }

    window.createTootsHome = `
      create table toots_home (
        id TEXT PRIMARY KEY,
        author_name TEXT,
        reblog_author_name TEXT,
        created_at TEXT,
        reblog_created_at TEXT,
        content TEXT,
        reblog_content TEXT,
        url TEXT,
        preview_url TEXT,
        media_url TEXT,
        media_type TEXT,
        reblog_preview_url TEXT,
        reblog_media_url TEXT,
        reblog_media_type TEXT
      )
    `

    window.updateTootsHome = function () {
      if (!window.ephemeralData || window.ephemeralData.length === 0) {
        return { sql: 'SELECT 1' }; // No-op if no data
      }

      const values = window.ephemeralData.map(toot => {
        const content = window.stripHtmlTags(toot.content || '');
        const reblogContent = window.stripHtmlTags(toot.reblog_content || '');
        const authorName = (toot.display_name || '').replace(/'/g, "''");
        const reblogAuthorName = (toot.reblog_display_name || '').replace(/'/g, "''");
        const url = (toot.instance_qualified_url || '').replace(/'/g, "''");

        const previewUrl = (toot.preview_url || '').replace(/'/g, "''");
        const mediaUrl = (toot.media_url || '').replace(/'/g, "''");
        const mediaType = (toot.media_type || '').replace(/'/g, "''");
        const reblogPreviewUrl = (toot.reblog_preview_url || '').replace(/'/g, "''");
        const reblogMediaUrl = (toot.reblog_media_url || '').replace(/'/g, "''");
        const reblogMediaType = (toot.reblog_media_type || '').replace(/'/g, "''");

        const inReplyToId = toot.in_reply_to_id || '';
        const inReplyToAccountId = toot.in_reply_to_account_id || '';
        const accountId = toot.account_id || '';
        const repliesCount = toot.replies_count || 0;

        return `('${toot.id}', '${authorName}', '${reblogAuthorName}', '${toot.created_at}', '${toot.reblog_created_at || ''}', '${content.replace(/'/g, "''")}', '${reblogContent.replace(/'/g, "''")}', '${url}', '${previewUrl}', '${mediaUrl}', '${mediaType}', '${reblogPreviewUrl}', '${reblogMediaUrl}', '${reblogMediaType}', '${inReplyToId}', '${inReplyToAccountId}', '${accountId}', ${repliesCount})`;
      }).join(',');

      return {
        sql: `
          INSERT OR IGNORE INTO toots_home (
            id,
            author_name,
            reblog_author_name,
            created_at,
            reblog_created_at,
            content,
            reblog_content,
            url,
            preview_url,
            media_url,
            media_type,
            reblog_preview_url,
            reblog_media_url,
            reblog_media_type,
            in_reply_to_id,
            in_reply_to_account_id,
            account_id,
            replies_count
          )
          VALUES ${values};
        `
      };
    }

    window.syncFTSAfterUpdate = function () {
      if (!window.ephemeralData || window.ephemeralData.length === 0) {
        return { sql: 'SELECT 1' }; // No-op if no data
      }

      const ids = window.ephemeralData.map(toot => `'${toot.id}'`).join(',');

      return {
        sql: `
          INSERT INTO toots_fts (
            id,
            author_name,
            reblog_author_name,
            content,
            reblog_content,
            created_at,
            reblog_created_at,
            url
          )
          SELECT
            id,
            author_name,
            reblog_author_name,
            content,
            reblog_content,
            created_at,
            reblog_created_at,
            url
          FROM toots_home
          WHERE id IN (${ids})
          AND id NOT IN (SELECT id FROM toots_fts);
        `
      };
    }

    window.countTootsHome = `
    select count(*) from toots_home
    `

    // notifications

    window.createNotifications = `
      create table notifications (
        id text primary key,
        category text,
        created_at text,
        account text,
        display_name text,
        account_url text,
        instance_qualified_account_url text,
        account_id text,
        status text,
        status_url text,
        instance_qualified_status_url text,
        status_content text,
        sp_connection_name text,
        sp_ctx text,
        _ctx text,

        -- Additional fields for UI display
        avatar_url text,
        header_url text,
        note text,
        followers_count integer,
        following_count integer,
        statuses_count integer,
        in_reply_to_id text,
        in_reply_to_account_id text,
        preview_url text,
        username text
      )
    `

    window.updateNotifications = `
      with limited_notifications as (
        select *
        from mastodon_notification
        order by created_at desc
        limit 50
      )
      insert or ignore into notifications (
        id,
        category,
        created_at,
        account,
        display_name,
        account_url,
        instance_qualified_account_url,
        account_id,
        status,
        status_url,
        instance_qualified_status_url,
        status_content,
        sp_connection_name,
        sp_ctx,
        _ctx,

        avatar_url,
        header_url,
        note,
        followers_count,
        following_count,
        statuses_count,
        in_reply_to_id,
        in_reply_to_account_id,
        preview_url,
        username
      )
      select
        id,
        category,
        created_at,
        account,
        display_name,
        account_url,
        instance_qualified_account_url,
        account_id,
        status,
        status_url,
        instance_qualified_status_url,
        status_content,
        sp_connection_name,
        sp_ctx,
        _ctx,

        json_extract(account, '$.avatar') as avatar_url,
        json_extract(account, '$.header') as header_url,
        json_extract(account, '$.note') as note,
        cast(json_extract(account, '$.followers_count') as integer) as followers_count,
        cast(json_extract(account, '$.following_count') as integer) as following_count,
        cast(json_extract(account, '$.statuses_count') as integer) as statuses_count,
        json_extract(status, '$.in_reply_to_id') as in_reply_to_id,
        json_extract(status, '$.in_reply_to_account_id') as in_reply_to_account_id,
        json_extract(status, '$.media_attachments[0].preview_url') as preview_url,
        json_extract(account, '$.username') as username
      from limited_notifications
    `

    window.countNotifications = `
      select count(*) as count from notifications
    `

    window.permanentNotifications = function (count) {
      return {
        sql: `
          select
            id,
            category,
            created_at,
            account,
            display_name,
            account_url,
            instance_qualified_account_url,
            account_id,
            status,
            status_url,
            instance_qualified_status_url,
            status_content,
            avatar_url,
            header_url,
            note,
            followers_count,
            following_count,
            statuses_count,
            in_reply_to_id,
            in_reply_to_account_id,
            preview_url,
            username
          from notifications
          order by created_at desc
          limit ${count}
        `
      }
    }

    window.getNotificationType = function (category) {
      if (!category) return '';

      const types = {
        'follow': 'followed you',
        'mention': 'mentioned you',
        'reblog': 'boosted your post',
        'favourite': 'favorited your post',
        'poll': 'poll has ended',
        'follow_request': 'requested to follow you',
        'status': 'posted a status',
        'update': 'updated a status'
      };

      return types[category] || category;
    }

    // search

    window.searchTootsHome = function (query) {
      return {
        sql: `
          SELECT *
          FROM toots_home
          WHERE
            author_name LIKE '%' || ? || '%'
            OR content LIKE '%' || ? || '%'
            OR reblog_author_name LIKE '%' || ? || '%'
            OR reblog_content LIKE '%' || ? || '%'
          ORDER BY created_at DESC
          LIMIT 50
        `,
        params: [query, query, query, query]
      };
    };

    // FTS search query sanitization
    window.sanitizeFTSQuery = function (query) {
      if (!query) return '';

      // Special case: single # should search for hashtags
      // Since FTS4 strips punctuation, we need a different approach
      if (query.trim() === '#') {
        // Return empty to trigger a special hashtag search
        return '';
      }

      // Escape FTS4 special characters: " - ( ) AND OR NOT
      // But preserve # for hashtag searches
      return query.replace(/["\-()]/g, ' ')
        .replace(/\b(AND|OR|NOT)\b/gi, ' ')
        .trim()
        .split(/\s+/)
        .filter(term => term.length > 0)
        .join(' ');
    }

    // FTS-based search function
    window.searchTootsAndNotifications = function (query) {
      // Special case: hashtag search
      if (query.trim() === '#') {
        return {
          sql: `
          SELECT * FROM (
            SELECT
              'toot' as result_type,
              id,
              author_name,
              reblog_author_name,
              created_at,
              reblog_created_at,
              COALESCE(content, '') as content,
              COALESCE(reblog_content, '') as reblog_content,
              url,
              NULL as display_name,
              NULL as username,
              NULL as avatar_url,
              NULL as reblog_display_name,
              NULL as reblog_username,
              NULL as reblog_avatar_url,
              NULL as category,
              NULL as account_url,
              'hashtag' as match_field,
              NULL as match_snippet
            FROM toots_home
            WHERE content LIKE '%#%' OR reblog_content LIKE '%#%'
          )
          ORDER BY created_at DESC
          `,
          params: []
        };
      }

      const sanitizedQuery = window.sanitizeFTSQuery(query);
      if (!sanitizedQuery) {
        return { sql: 'SELECT NULL LIMIT 0' }; // Return empty result for empty query
      }

      return {
        sql: `
        WITH unique_toot_ids AS (
          SELECT DISTINCT tf.id
          FROM toots_fts tf
          WHERE toots_fts MATCH ?
        ),
        unique_notification_ids AS (
          SELECT DISTINCT nf.id
          FROM notifications_fts nf
          WHERE notifications_fts MATCH ?
        )
        SELECT * FROM (
          SELECT
            'toot' as result_type,
            th.id,
            th.author_name,
            th.reblog_author_name,
            th.created_at,
            th.reblog_created_at,
            COALESCE(th.content, '') as content,
            COALESCE(th.reblog_content, '') as reblog_content,
            th.url,
            NULL as display_name,
            NULL as username,
            NULL as avatar_url,
            NULL as reblog_display_name,
            NULL as reblog_username,
            NULL as reblog_avatar_url,
            NULL as category,
            NULL as account_url,
            CASE
              WHEN th.author_name LIKE '%' || ? || '%' THEN 'author'
              WHEN th.reblog_author_name LIKE '%' || ? || '%' THEN 'reblog_author'
              WHEN th.content LIKE '%' || ? || '%' THEN 'content'
              WHEN th.reblog_content LIKE '%' || ? || '%' THEN 'reblog_content'
              ELSE 'content'
            END as match_field,
            CASE
              WHEN th.content LIKE '%' || ? || '%' THEN
                SUBSTR(th.content,
                  MAX(1, INSTR(LOWER(th.content), LOWER(?)) - 60),
                  160)
              WHEN th.reblog_content LIKE '%' || ? || '%' THEN
                SUBSTR(th.reblog_content,
                  MAX(1, INSTR(LOWER(th.reblog_content), LOWER(?)) - 60),
                  160)
              WHEN th.author_name LIKE '%' || ? || '%' THEN
                th.author_name || ': ' || SUBSTR(COALESCE(th.content, th.reblog_content, ''), 1, 40)
              ELSE
                SUBSTR(COALESCE(th.content, th.reblog_content, ''), 1, 64)
            END as match_snippet
          FROM unique_toot_ids uti
          JOIN toots_home th ON uti.id = th.id

          UNION ALL

          SELECT
            'notification' as result_type,
            n.id,
            n.display_name as author_name,
            NULL as reblog_author_name,
            n.created_at,
            NULL as reblog_created_at,
            COALESCE(n.status_content, '') as content,
            NULL as reblog_content,
            n.status_url as url,
            n.display_name,
            NULL as username,
            NULL as avatar_url,
            NULL as reblog_display_name,
            NULL as reblog_username,
            NULL as reblog_avatar_url,
            n.category,
            n.account_url,
            CASE
              WHEN n.display_name LIKE '%' || ? || '%' THEN 'author'
              WHEN n.status_content LIKE '%' || ? || '%' THEN 'content'
              WHEN n.note LIKE '%' || ? || '%' THEN 'bio'
              WHEN n.category LIKE '%' || ? || '%' THEN 'category'
              ELSE 'content'
            END as match_field,
            CASE
              WHEN n.status_content LIKE '%' || ? || '%' THEN
                SUBSTR(n.status_content,
                  MAX(1, INSTR(LOWER(n.status_content), LOWER(?)) - 60),
                  160)
              WHEN n.display_name LIKE '%' || ? || '%' THEN
                n.display_name || ': ' || SUBSTR(COALESCE(n.status_content, ''), 1, 40)
              WHEN n.note LIKE '%' || ? || '%' THEN
                SUBSTR(n.note,
                  MAX(1, INSTR(LOWER(n.note), LOWER(?)) - 60),
                  160)
              ELSE
                SUBSTR(COALESCE(n.status_content, n.note, ''), 1, 64)
            END as match_snippet
          FROM unique_notification_ids uni
          JOIN notifications n ON uni.id = n.id
        )
        ORDER BY created_at DESC
        LIMIT 30
        `,
        params: [sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery, sanitizedQuery]
      };
    }

    // stats
    window.tableStats =
      `
          SELECT
            'notifications' AS table_name,
            (SELECT COUNT(*) FROM notifications) AS row_count,
            (SELECT SUM(pgsize) FROM dbstat WHERE name = 'notifications') AS size_bytes,
            ROUND((SELECT SUM(pgsize) FROM dbstat WHERE name = 'notifications') / 1024.0, 2) AS size_kb,
            ROUND(
              1.0 * (SELECT SUM(pgsize) FROM dbstat WHERE name = 'notifications') /
              NULLIF((SELECT COUNT(*) FROM notifications), 0), 2
            ) AS bytes_per_row

          UNION ALL

          SELECT
            'follower',
            (SELECT COUNT(*) FROM follower),
            (SELECT SUM(pgsize) FROM dbstat WHERE name = 'follower'),
            ROUND((SELECT SUM(pgsize) FROM dbstat WHERE name = 'follower') / 1024.0, 2),
            ROUND(
              1.0 * (SELECT SUM(pgsize) FROM dbstat WHERE name = 'follower') /
              NULLIF((SELECT COUNT(*) FROM follower), 0), 2
            )

          UNION ALL

          SELECT
            'following',
            (SELECT COUNT(*) FROM following),
            (SELECT SUM(pgsize) FROM dbstat WHERE name = 'following'),
            ROUND((SELECT SUM(pgsize) FROM dbstat WHERE name = 'following') / 1024.0, 2),
            ROUND(
              1.0 * (SELECT SUM(pgsize) FROM dbstat WHERE name = 'following') /
              NULLIF((SELECT COUNT(*) FROM following), 0), 2
            )

          UNION ALL

          SELECT
            'toots_home',
            (SELECT COUNT(*) FROM toots_home),
            (SELECT SUM(pgsize) FROM dbstat WHERE name = 'toots_home'),
            ROUND((SELECT SUM(pgsize) FROM dbstat WHERE name = 'toots_home') / 1024.0, 2),
            ROUND(
              1.0 * (SELECT SUM(pgsize) FROM dbstat WHERE name = 'toots_home') /
              NULLIF((SELECT COUNT(*) FROM toots_home), 0), 2
            );
      `

    // helpers

    window.customSql = function (query) {
      //console.log('Running query:', query);
      return {
        sql: query
      }
    }

    window.usernameCache = {};

    window.accountCache = {};

    window.lookupAccount = function (accountId) {
      // Return from cache if available
      if (window.accountCache[accountId]) {
        return { sql: 'select 1' };
      }

      return {
        sql: `select id, username, display_name, url from mastodon_account where id = '${accountId}'`
      };
    }

    window.getCount = function (obj, property) {
      if (!obj || !property) return 0;
      const value = obj[property];
      if (value === undefined || value === null) return 0;

      // Try to convert to number, return 0 if it fails
      const num = parseInt(value, 10);
      return isNaN(num) ? 0 : num;
    }

    window.getDisplayName = function (item) {
      if (!item) return '';
      return item.display_name ? item.display_name : item.username || '';
    }

    window.getReblogDisplayName = function (item) {
      if (!item) return '';
      return item.reblog_display_name ? item.reblog_display_name : item.reblog_username || '';
    }

    window.getUsername = function (item) {
      if (!item) return '';
      return item.username || '';
    }

    window.getReblogUsername = function (item) {
      if (!item) return '';
      return item.reblog_username || '';
    }

    window.transformNotificationStatus = function (status) {
      if (!status) return status;

      // Transform the notification status JSON to match RegularPost expectations
      return {
        ...status,
        // Map account fields to top-level fields expected by RegularPost
        avatar_url: status.account?.avatar_static || status.account?.avatar,
        display_name: status.account?.display_name,
        username: status.account?.username,
        // Map account profile fields for MastodonAvatar modal
        followers_count: status.account?.followers_count || 0,
        following_count: status.account?.following_count || 0,
        statuses_count: status.account?.statuses_count || 0,
        note: status.account?.note || '',
        header_url: status.account?.header_static || status.account?.header,
        // Keep post creation date for timestamp display
        created_at: status.created_at,
        // Add account creation date for avatar modal join date
        account_created_at: status.account?.created_at,
        content: status.content,
        favourites_count: status.favourites_count || 0,
        reblogs_count: status.reblogs_count || 0,
        replies_count: status.replies_count || 0,
        favourited: status.favourited || false,
        reblogged: status.reblogged || false
      };
    }

    window.transformSingleTootForAvatar = function (tootData) {
      // Transform mastodon_single_toot data to match MastodonAvatar expectations
      const account = tootData.account ? (typeof tootData.account === 'string' ? JSON.parse(tootData.account) : tootData.account) : {};

      return {
        ...tootData,
        // Map field names to what MastodonAvatar expects
        followers_count: tootData.followers || account.followers_count || 0,
        following_count: tootData.following || account.following_count || 0,
        statuses_count: account.statuses_count || 0,
        note: account.note || '',
        header_url: account.header_static || account.header || tootData.header_url,
        // Keep existing fields
        avatar_url: tootData.avatar_url || account.avatar_static || account.avatar,
        display_name: tootData.display_name || account.display_name,
        username: tootData.username || account.username,
        url: tootData.instance_qualified_account_url || account.url
      };
    }

    window.lookupUsername = function (accountId) {
      if (!accountId) return null;

      // Return from cache if available
      if (window.usernameCache[accountId]) {
        return { username: window.usernameCache[accountId] };
      }

      return {
        sql: `SELECT username FROM mastodon_account WHERE id = '${accountId}'`,
        then: function (result) {
          if (result && result.length > 0) {
            // Store username in cache for future use
            window.usernameCache[accountId] = result[0].username;
            return { username: result[0].username };
          }
          return { username: null };
        }
      };
    }

    window.hasHeader = function (header_url) {
      return header_url && !header_url.includes('/missing.png')
    }

    window.avatarTopMargin = function (header_url) {
      return window.hasHeader(header_url) ? '-2rem' : '0'
    }

    // link truncation
    window.enableLinkTruncation = function () {
      document.body.classList.add('truncate-links');
    }

    window.disableLinkTruncation = function () {
      document.body.classList.remove('truncate-links');
    }

    function initTruncateLinksSetting() {
      let truncate = localStorage.getItem('truncateLinks');
      if (truncate === null) {
        truncate = 'true';
        localStorage.setItem('truncateLinks', truncate);
      }
    }
    window.addEventListener('DOMContentLoaded', initTruncateLinksSetting);

    window.setTruncateLinks = function (enabled) {
      console.log('truncate', enabled)
      localStorage.setItem('truncateLinks', enabled ? 'true' : 'false');
      if (enabled) {
        window.enableLinkTruncation();
      } else {
        window.disableLinkTruncation();
      }
    }

    window.getPostId = function (item) {
      if (item.reblog) {
        return JSON.parse(item.reblog).id;
      }
      return item.id;
    }

    window.getPostFavourited = function (item) {
      if (item.reblog) {
        return JSON.parse(item.reblog).favourited;
      }
      return item.favourited;
    }

    window.getPostReblogged = function (item) {
      if (item.reblog) {
        return JSON.parse(item.reblog).reblogged;
      }
      return item.reblogged;
    }

    window.getPostBookmarked = function (item) {
      if (item.reblog) {
        return JSON.parse(item.reblog).bookmarked;
      }
      return item.bookmarked;
    }

    // Recursively build nested reply structure
    window.buildNestedReplies = function(allToots, parentId) {
      // Find all direct children of this parent
      const children = allToots.filter(t => t.in_reply_to_id === parentId);

      // Sort chronologically (forum style - oldest first)
      children.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

      // Recursively build each child's replies
      return children.map(child => ({
        ...child,
        replies: window.buildNestedReplies(allToots, child.id)
      }));
    }

    window.enrichTootsWithReplies = function(toots, persistedReplies = []) {
      console.log('enrichTootsWithReplies: processing', toots.length, 'live toots +', persistedReplies.length, 'persisted replies');

      // Merge live toots with persisted replies
      const allToots = [...toots, ...persistedReplies];

      // Create a Set of IDs for deduplication
      const tootIds = new Set(toots.map(t => t.id));

      // Filter out persisted replies that are already in live data
      const uniquePersistedReplies = persistedReplies.filter(r => !tootIds.has(r.id));
      const combined = [...toots, ...uniquePersistedReplies];

      console.log('Combined:', combined.length, 'total unique toots');

      // Build ID set of all toots
      const allTootIds = new Set(combined.map(t => t.id));

      // Debug: show toots with in_reply_to_id
      const repliesInData = combined.filter(t => t.in_reply_to_id);
      console.log('DEBUG: Found', repliesInData.length, 'toots with in_reply_to_id');
      if (repliesInData.length > 0) {
        const sample = repliesInData[0];
        console.log('DEBUG: Sample reply:', {
          sample: sample,
          id: sample.id,
          name: sample.display_name,
          in_reply_to_id: sample.in_reply_to_id,
          parentExists: allTootIds.has(sample.in_reply_to_id)
        });
      }

      // Identify top-level toots (not a reply to something in our dataset)
      const topLevelToots = combined.filter(t =>
        !t.in_reply_to_id || !allTootIds.has(t.in_reply_to_id)
      );

      console.log('Found', topLevelToots.length, 'top-level toots');

      // Build nested structure for each top-level toot
      const enriched = topLevelToots.map(toot => ({
        ...toot,
        replies: window.buildNestedReplies(combined, toot.id)
      }));

      console.log('Enriched:', enriched.filter(t => t.replies.length > 0).length, 'toots have nested replies');

      // Show a parent/replies example
      const parentWithReplies = enriched.find(t => t.replies.length > 0);
      if (parentWithReplies) {
        console.log('===== PARENT/REPLIES =====');
        console.log('PARENT:', {
          id: parentWithReplies.id,
          author: parentWithReplies.display_name,
          content: parentWithReplies.content?.substring(0, 100),
          replyCount: parentWithReplies.replies.length
        });
        parentWithReplies.replies.forEach((reply, idx) => {
          console.log(`REPLY ${idx + 1}:`, {
            id: reply.id,
            author: reply.display_name,
            in_reply_to_id: reply.in_reply_to_id,
            content: reply.content?.substring(0, 100)
          });
        });
      }

      return enriched;
    }

    window.debugListItem = function(item, index) {
      if (index === 0) {
        console.log('First List item properties:', {
          id: item.id,
          author: item.author_name,
          hasReplies: 'replies' in item,
          repliesCount: item.replies ? item.replies.length : 0,
          firstReplyHasReplies: item.replies && item.replies[0] ? item.replies[0].replies.length : 0
        });
      }
      return true;
    }

    window.listAllTables = `
      select name from sqlite_master where type='table' order by name
    `

    window.stripHtmlTags = function (html) {
      if (!html) return '';
      return html.replace(/<[^>]*>/g, '').trim();
    }

    // Visibility helper functions
    window.getVisibilityIcon = function (visibility) {
      switch (visibility) {
        case 'public':
          return 'globe';
        case 'unlisted':
          return 'permissions';
        case 'private':
          return 'users';
        case 'direct':
          return 'send';
        default:
          return 'send';
      }
    }

    window.getVisibilityDescription = function (visibility) {
      switch (visibility) {
        case 'public':
          return 'all';
        case 'unlisted':
          return 'all (not searchable)';
        case 'private':
          return 'followers';
        case 'direct':
          return 'people I @-mention';
        default:
          return 'all'
      }
    }

    window.htmlToMarkdown = function (html) {
      if (!html) return '';

      // Convert HTML entities to characters
      let content = html.replace(/&#39;/g, "'")
        .replace(/&quot;/g, '"')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>');

      // Remove HTML tags but preserve content
      content = content.replace(/<p>/gi, '')
        .replace(/<\/p>/gi, '\n\n')
        .replace(/<br\s*\/?>/gi, '\n\n')
        .replace(/<[^>]*>/g, ''); // Remove any remaining HTML tags

      // Clean up extra whitespace
      content = content.replace(/\n{3,}/g, '\n\n') // Max 2 consecutive newlines
        .trim();

      return content;
    }

    /*
    // Test the function
    console.log('Testing htmlToMarkdown function...');
    const testHtml = '<p>**BARACK OBAMA**: If convictions don&#39;t cost anything, then they&#39;re really just kind of fashion. They&#39;re not really convictions. We were so accustomed to things getting better consistently, a little less racist, a little less sexist, less homophobic, a little more generous, that it was easy to say, well, yeah, I&#39;m a progressive. We could take positions on things but they were never really tested.<br />**MARC MARON**: Right.<br />**BARACK OBAMA**: Well, here&#39;s the test.</p>';
    const testResult = window.htmlToMarkdown(testHtml);
    console.log('Test input:', testHtml);
    console.log('Test output:', testResult);
    */

    // FTS (Full-Text Search) Infrastructure

    window.createFTSToots = function () {
      return {
        sql: `
          CREATE VIRTUAL TABLE IF NOT EXISTS toots_fts USING fts4(
            id,
            author_name,
            reblog_author_name,
            content,
            reblog_content,
            created_at,
            reblog_created_at,
            url
          );
        `
      };
    }

    window.populateFTSToots = function () {
      return {
        sql: `
          INSERT INTO toots_fts(
            id, author_name, reblog_author_name, content, reblog_content,
            created_at, reblog_created_at, url
          )
          SELECT
            id, author_name, reblog_author_name, content, reblog_content,
            created_at, reblog_created_at, url
          FROM toots_home
          WHERE NOT EXISTS (SELECT 1 FROM toots_fts LIMIT 1);
        `
      };
    }

    window.createFTSNotifications = function () {
      return {
        sql: `
          CREATE VIRTUAL TABLE IF NOT EXISTS notifications_fts USING fts4(
            id,
            display_name,
            status_content,
            note,
            category,
            created_at,
            status_url,
            account_url
          );
        `
      };
    }

    window.populateFTSNotifications = function () {
      return {
        sql: `
          INSERT INTO notifications_fts(
            id, display_name, status_content, note, category,
            created_at, status_url, account_url
          )
          SELECT
            id, display_name, status_content, note, category,
            created_at, status_url, account_url
          FROM notifications
          WHERE NOT EXISTS (SELECT 1 FROM notifications_fts LIMIT 1);
        `
      };
    }

    window.initializeFTS = function () {
      // Prevent multiple initialization
      if (window.ftsInitialized) {
        console.log('FTS already initialized, skipping...');
        return { sql: 'SELECT 1 as already_initialized' };
      }

      return {
        sql: `
          -- Create FTS4 virtual table for toots
          CREATE VIRTUAL TABLE IF NOT EXISTS toots_fts USING fts4(
            id,
            author_name,
            reblog_author_name,
            content,
            reblog_content,
            created_at,
            reblog_created_at,
            url
          );

          -- Create FTS4 virtual table for notifications
          CREATE VIRTUAL TABLE IF NOT EXISTS notifications_fts USING fts4(
            id,
            display_name,
            status_content,
            note,
            category,
            created_at,
            status_url,
            account_url
          );

          -- Only populate if tables are empty (prevents duplicates)
          INSERT INTO toots_fts(
            id, author_name, reblog_author_name, content, reblog_content,
            created_at, reblog_created_at, url
          )
          SELECT
            id, author_name, reblog_author_name, content, reblog_content,
            created_at, reblog_created_at, url
          FROM toots_home
          WHERE NOT EXISTS (SELECT 1 FROM toots_fts LIMIT 1);

          INSERT INTO notifications_fts(
            id, display_name, status_content, note, category,
            created_at, status_url, account_url
          )
          SELECT
            id, display_name, status_content, note, category,
            created_at, status_url, account_url
          FROM notifications
          WHERE NOT EXISTS (SELECT 1 FROM notifications_fts LIMIT 1);
        `
      };
    }

    // Debug functions for FTS verification
    window.checkFTSTables = function () {
      return {
        sql: `
          SELECT name, sql
          FROM sqlite_master
          WHERE type='table' AND name LIKE '%_fts'
          ORDER BY name
        `
      };
    }

    window.countFTSRecords = function () {
      return {
        sql: `
          SELECT
            'toots_fts' as table_name,
            (SELECT COUNT(*) FROM toots_fts) as count
          UNION ALL
          SELECT
            'notifications_fts' as table_name,
            (SELECT COUNT(*) FROM notifications_fts) as count
          UNION ALL
          SELECT
            'toots_home' as table_name,
            (SELECT COUNT(*) FROM toots_home) as count
          UNION ALL
          SELECT
            'notifications' as table_name,
            (SELECT COUNT(*) FROM notifications) as count
        `
      };
    }

  </script>
</head>

<body>
</body>

</html>
