<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="xmlui/0.9.13.js"></script>
    <script src="xmlui/charts-0.1.12.js"></script>
    <script src="config.js"></script>
    <script>
        window.pipesQuery = 'http://localhost:8080/proxy/pipes.turbot.com/api/latest/user/jonudell/workspace/mastodon/query'

        window.windowValue = 0;

        window.init = function () {
            return { sql: `select steampipe_configure_github('token="${window.config.githubToken}"')` }
        }

        window.updateQueryWithNonce = function(query, appStateUpdateFn) {
            console.log('Executing query:', query);
            // Get the raw query without any existing nonce comment
            const rawQuery = query.replace(/^-- [0-9]+\n\n/, '');
            // Add nonce comment at the beginning
            const queryWithNonce = `-- ${Date.now()}\n\n${rawQuery}`;
            console.log('Modified query with nonce:', queryWithNonce);

            // Update the app state
            appStateUpdateFn({
                example: queryWithNonce,
                loading: true,
                results: []
            });

            return queryWithNonce;
        }

        // Custom SQL query function
        window.customSql = function(query) {
            console.log('Running query:', query);
            return {
                sql: query
            }
        }

        // Cache for usernames to avoid duplicate queries
        window.usernameCache = {};

        window.tootsHome = function (count) {
            return {
                sql: `
                /*
                 * Note about reply usernames:
                 * We only return the in_reply_to_account_id field here.
                 * The Mastodon Steampipe plugin doesn't allow joining with
                 * mastodon_account table without a specific filter on the id.
                 *
                 * To get usernames for replies, we'll batch-process these after
                 * the initial query returns, using the usernameCache.
                 */
                SELECT
                  id,
                  username,
                  display_name,
                  created_at,
                  url,
                  instance_qualified_url,
                  status,
                  reblog,
                  (status->>'replies_count')::int as replies_count,
                  (status->>'reblogs_count')::int as reblogs_count,
                  (status->>'favourites_count')::int as favourites_count,
                  account::json->>'avatar' as avatar_url,
                  CASE
                    WHEN reblog IS NOT NULL THEN
                      reblog::json->'account'->>'avatar'
                    ELSE
                      NULL
                  END AS reblog_avatar_url,
                  status->>'in_reply_to_id' as in_reply_to_id,
                  status->>'in_reply_to_account_id' as in_reply_to_account_id
                FROM mastodon_toot_home
                ORDER BY created_at DESC
                LIMIT ${count}
                `
            }
        }

        window.formatDate = function(dateString) {
            if (!dateString) return '';
            try {
                const date = new Date(dateString);
                return date.toLocaleString();
            } catch (e) {
                return dateString || '';
            }
        }

        window.getCount = function(obj, property) {
            if (!obj || !property) return 0;
            const value = obj[property];
            if (value === undefined || value === null) return 0;

            // Try to convert to number, return 0 if it fails
            const num = parseInt(value, 10);
            return isNaN(num) ? 0 : num;
        }

        // Global variable to store loaded toots
        window.loadedToots = [];

        // Manual function to load toots
        window.loadTootsManually = function() {
            const query = tootsHome(20);

            // Construct the request options
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + window.config.pipesToken,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(query)
            };

            // Show loading state
            console.log('Loading toots...');

            // Make the fetch request
            fetch(window.pipesQuery, options)
                .then(response => response.json())
                .then(data => {
                    console.log('Toots loaded:', data);
                    window.loadedToots = data.items || [];

                    // Force a re-render by dispatching a custom event
                    document.dispatchEvent(new CustomEvent('toots-loaded'));
                })
                .catch(error => {
                    console.error('Error loading toots:', error);
                });
        }

        // Function to look up a username from an account ID - used by tootsHome
        window.lookupUsername = function(accountId) {
            if (!accountId) return null;

            // Return from cache if available
            if (window.usernameCache[accountId]) {
                return { username: window.usernameCache[accountId] };
            }

            return {
                sql: `SELECT username FROM mastodon_account WHERE id = '${accountId}'`,
                then: function(result) {
                    if (result && result.length > 0) {
                        // Store username in cache for future use
                        window.usernameCache[accountId] = result[0].username;
                        return { username: result[0].username };
                    }
                    return { username: null };
                }
            };
        }

        // Helper functions to open profile dialog
        window.openUserProfile = function(itemId) {
            // Find the item in the data
            const items = document.querySelector('[data="{tootsHome}"]').__antmlData;
            if (!items || !items.length) return;

            const item = items.find(i => i.id === itemId);
            if (!item) return;

            // Open the dialog with profile info
            const dialog = document.getElementById('userProfileDialog');
            if (dialog && dialog.__antmlComponent && dialog.__antmlComponent.open) {
                dialog.__antmlComponent.open({
                    avatar_url: item.avatar_url,
                    display_name: item.display_name,
                    username: item.username
                });
            }
        }

        window.openReblogUserProfile = function(itemId) {
            // Find the item in the data
            const items = document.querySelector('[data="{tootsHome}"]').__antmlData;
            if (!items || !items.length) return;

            const item = items.find(i => i.id === itemId);
            if (!item || !item.reblog || !item.reblog.account) return;

            // Open the dialog with profile info
            const dialog = document.getElementById('userProfileDialog');
            if (dialog && dialog.__antmlComponent && dialog.__antmlComponent.open) {
                dialog.__antmlComponent.open({
                    avatar_url: item.reblog_avatar_url,
                    display_name: item.reblog.account.display_name,
                    username: item.reblog.account.username
                });
            }
        }

    </script>
</head>

<body>
</body>

</html>